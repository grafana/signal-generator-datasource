syntax = "proto3";
package pluginv2;

option go_package = ".;pluginv2";

//-----------------------------------------------
// Topics
//-----------------------------------------------

// The message exist within a channel, so the plugin/id is already implicit
// This is general purpose and the body will determine the behavior.  If a timestamp is
// needed, it can be in the json body
message ChannelMessage {
  enum MessageType {
    TEXT = 1;
    JSON = 2;
    DATA_FRAME = 3;  // OR?? https://arrow.apache.org/docs/format/Columnar.html#ipc-streaming-format
    DATA_FRAME_APPEND = 4; // Append rows to an existing frame
    PROTOBUF = 5; // The channel knows how to decode
  }
  bytes payload = 4;
  MessageType type = 5;
}

message JoinRequest {
  PluginContext pluginContext = 1;

  // Info about the user who calls the plugin.
  User user = 3;

  // Name of the channel: includes ${plugin}/${id} prefix! 
  string channel = 4;
}

message ChannelInfo {
  string name = 3;
  string description = 4;

  // Info sent to the client when they join
  bytes infoJSON = 5; 
}

message JoinResponse {
  string error = 1; // If an effor exists, the client will not be subscribed and 
  ChannelInfo channel = 4; // initial metadata about the 
  repeated ChannelMessage welcome = 1; // first messages sent after connect
}

message ChannelRequest {
  PluginContext pluginContext = 1;

  string channel = 4;
}

service StreamingService {
  // Single stream that is called for every instance.  
  rpc OnJoin(JoinRequest) returns (JoinResponse); // return error if not allowed

  // The listener will disconnect when there are no more subscribers
  // The plugin will close the connection if there are no more messages on this channel
  // Only one stream will be open for each channel
  rpc RunChannel(ChannelRequest) returns (stream ChannelMessage);
}

